/* 
OS20180312-OS20180315;
Создание. 
Запуск на группах (папках). Обрабатывается группа и все ее подгруппы.
Группа верхнеуровневого описания БП определяется наличием в ней диаграммы типа VAD с префиксом "_Окружение". 
Для БП, на которые распространяется СМК, перед графическими моделями дополнительно включаются
текстовые разделы: Цель БП, Первичные входы БП, Первичные выходы БП, Вторичные входы БП, 
Вторичные выходы БП, Ресурсы БП, Оценка результативности БП. Определяется проставленным атрибутом 
"Относится к ISO 9000" у объекта БП. Объект БП определяется по функции "Цепь создания добавленной
стоимости" на модели окружения БП и обязательно должен быть в единичном экземпляре на данной модели.
Книжная/альбомная ориентация листа отчета задается в соответствии с заданными параметрами каждой модели.

Доступные настройки формирования:
- заголовки могут выводится без дополнительной нумерации или быть пронумерованы;
- отчет может формироваться с выбранной группы или начиная ее подгрупп;
- сортировка "По номеру в иерархии" или "По геометрии";
- возможность формирования без графических изображений моделей;
Настройки сохраняются до следующего вызова отчета.

OS20180320;
Изменения:
- добавлена нумерация БП в сводных таблицах;
*/

var g_nloc = 0; // Variable for the ID of the selected language.
var g_ooutfile = null; // Object for output of report.
var ogroups = null;
var TOCnumLev = [0,0,0,0,0,0,0]; // счетчик разделов содержания.
var isWorkFromParentGroup = false; // флаг необходимости включения в отчет верхней группы
var isOuputPictures = true; // флаг вывода графики
var isOpenSection = false; // флаг открытой секции
var isTOCNumbering = true; // флаг генерации нумерации оглавления
var isGeometryStruct = true; // флаг типа постраения структуры
var SortType1; // переменная для задания вида сортировки
var SortType2; // переменная для задания вида сортировки
var PicW = 0;
var PicH = 0;

function main()
{
    var bcheckuserdialog = new __holder(false);   // variable to check for the interruption of userdialog
    Context.setProperty("use-new-output", true);
    ogroups = ArisData.getSelectedGroups();
    g_nloc = __toLong(Context.getSelectedLanguage());
    g_ooutfile = Context.createOutputObject(Context.getSelectedFormat(), Context.getSelectedFile());
    g_ooutfile.Init(Context.getSelectedLanguage());
    // Форматы строк для формирования отчета
    g_ooutfile.DefineF("Caption0", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY0, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("Caption1", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY1, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("Caption2", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY2, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("Caption3", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY3, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("Caption4", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY4, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("Caption5", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY5, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("Caption6", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY6, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("Caption7", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY7, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("Caption8", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY8, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("SmallCaption0", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY0, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("SmallCaption1", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY1, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("SmallCaption2", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY2, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("SmallCaption3", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY3, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("SmallCaption4", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY4, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("SmallCaption5", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY5, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("SmallCaption6", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY6, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("SmallCaption7", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY7, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("SmallCaption8", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD | Constants.FMT_TOCENTRY8, 0, 21, 0, 0, 0, 1);
    g_ooutfile.DefineF("Title 1", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_LEFT,95,0,0,0,0,1);      
    g_ooutfile.DefineF("Title 2", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_RIGHT,0,0,0,0,0,0);
    g_ooutfile.DefineF("Title 3", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_CENTER,0,0,0,0,0,1);
    g_ooutfile.DefineF("Title 4", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_LEFT,95,0,0,0,0,1);
    g_ooutfile.DefineF("Caption", "Times New Roman",14,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_CENTER,0,0,0,0,0,1);
    g_ooutfile.DefineF("Footer", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_CENTER,2,0,0,0,0,1);
    g_ooutfile.DefineF("Regular","Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY, 0, 0, 0, 0, 0, 1);
    g_ooutfile.DefineF("Header", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_LEFT | Constants.FMT_BOLD,0,0,0,0,0,1);
    g_ooutfile.DefineF("Table", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_LEFT,1,1,0,0,0,1);
    g_ooutfile.DefineF("TableCenter", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_CENTER,1,1,0,0,0,1);
    g_ooutfile.DefineF("TableHat", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_CENTER | Constants.FMT_VCENTER,1,1,0,0,0,1);
    g_ooutfile.DefineF("Indent0","Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY, 0, 0, 0, 0, 0, 1);
    g_ooutfile.DefineF("Indent1","Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY, 10, 0, 0, 0, 0, 1);
    g_ooutfile.DefineF("Indent2","Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY, 20, 0, 0, 0, 0, 1);
    g_ooutfile.DefineF("Indent3","Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY, 30, 0, 0, 0, 0, 1);
    g_ooutfile.DefineF("Indent4","Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY, 40, 0, 0, 0, 0, 1);
    g_ooutfile.DefineF("RegularBold", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_JUSTIFY | Constants.FMT_BOLD, 0, 0, 0, 0, 0, 1);
    // если что-то выбрано
    if (ogroups.length == 1) {
        showOutputOptionsDialog(bcheckuserdialog); 
        if (bcheckuserdialog.value == true) { 
            isWorkFromParentGroup = bcheckuserdialog.workFromParentGroup;
            isOuputPictures = bcheckuserdialog.OuputPictures;
            isTOCNumbering = bcheckuserdialog.TOCNumbering;
            isGeometryStruct = bcheckuserdialog.GeometryStruct;
            SortType1 = bcheckuserdialog.SortMethod;
            SortType2 = Constants.SORT_GEOMETRIC;
            isOpenSection = false;

            // записали информацию
            OutputReport(ogroups);
            // Отрисовка нижнего колонтитула
            Footer(g_ooutfile);
            // закрыли секцию
            if (isOpenSection) g_ooutfile.EndSection();
            // вывели отчет
            g_ooutfile.WriteReport(Context.getSelectedPath(), Context.getSelectedFile());
        } else {
            Context.setScriptError(Constants.ERR_CANCEL);
        }
    } else {
        Context.setScriptError(Constants.ERR_CANCEL);
    }
}

function OutputReport(ogroups)
{

    var OutputTableLine = []; // массив строчки вывода
    var ChildGroups = []; // массив подчиненных групп
    var ParentGroup; // группа запуска
    var CurrentGroup; // переменная для текущей (обрабатываемой) группы
    
    var DocumentStructure = []; // массив для подчиненных групп - структура документа
    var Indent = new __holder(0); // переменная для отступа
    var FontStyle = ""; // переменная для стиля шрифта
    var FontStyleModels = ""; // переменная для стиля шрифта заголовков моделией БП
    var NameOfGroup = ""; // переменная для имени категории группы
    var NameOfBP = ""; // переменная для имени группы - название БП
    var ArrayOfModels = []; // массив для моделей текущей (обрабатываемой) группы
    var HeaderList = []; // переменная сбора родительских групп для вывода их на одном листе с группой модели
    
    var ModelOfOccurrence; // переменная модели окружения БП
    var ModelOfExperts; // переменная модели экспертов БП
    var ModelOfMembers; // переменная модели участников БП
    var ModelOfRelationship; // переменная взаимосвязей БП
    var ModelOfStructure; // переменная структуры БП
    var BPObjOccOccur = []; // массив для экземпляров объектов на модели окружения БП 
    var BPObjOccRelat = []; // массив для экземпляров объектов на модели взаимосвязей БП
    var BPObjOccStruct = []; // массив для экземпляров объектов на модели структуры БП
    var TargetOfBP = []; // массив для целей БП
    var FirstIn = []; // массив для первичных входов БП
    var FirstOut = []; // массив для первичных выходов БП
    var SecondIn = []; // массив для вторичных входов БП
    var SecondOut = []; // массив для вторичных выходов БП
    var ABBRList = []; // массив для сбора аббривиатур
    
    var isSMKModel; // флаг СМК модели
    var isULDModel; // флаг модели верхнеуровневого описания upper level description model
    
    var CxnListOccur = []; // массив для связей на модели окружения БП
    var CxnListRelat = []; // массив для связей на модели взаимоотношений БП 
    
    var ListOfExperts = []; // массив для сбора информации о экспертах БП и их БП
    var ListOfOwners = []; // массив для сбора информации о владельцах БП и их БП

    // Определяем структуру документа из вложенности групп (папок).
    ParentGroup = ogroups[0];
    if (isWorkFromParentGroup) { // если установлен флаг включения родительской группы в отчет, то включаем ее в отчет
        DocumentStructure.push(new Array(ParentGroup,Indent.value)); 
        Indent.value++; // сдвигаем уровень иерархии
    }    
    
    ChildGroups = ParentGroup.Childs(false); // получаем подчиненные группы родительской и передаем в работу
    ChildGroups = __sort(ChildGroups, Constants.AT_NAME, g_nloc);
    DetectStructure(ChildGroups, Indent, DocumentStructure); // перебираем все подгруппы и определяем их подчиненность для использования в построении структуры документа

    if (DocumentStructure.length > 0) {

        // Задание начальных параметров страницы
        g_ooutfile.SetPrintScaling(120);
        PortraitPage(true, g_ooutfile);
        
        // Отрисовка титульника
        g_ooutfile.BeginSection(false, Constants.SECTION_COVER);
        g_ooutfile.OutputLnF("УТВЕРЖДЕНО","Title 1");
        g_ooutfile.OutputLnF("Протокол","Title 4");
        g_ooutfile.OutputLnF("Проектно-процессного комитета","Title 4");                
//        g_ooutfile.OutputLnF("комитета","Title 4");                
        g_ooutfile.OutputLnF("ОАО «Белагропромбанк»","Title 4"); 
        g_ooutfile.OutputLnF("___.___.______ № ____","Title 1");         
        for (var i=0; i<5; i++) g_ooutfile.OutputLnF("","Title 2");     
        g_ooutfile.OutputLnF("БИЗНЕС-МОДЕЛЬ","Title 2");                
        g_ooutfile.OutputLnF("ОАО \«Белагропромбанк\»","Title 2");                
        g_ooutfile.OutputLnF("\«как есть\»","Title 2");
        for (var i=0; i<11; i++) g_ooutfile.OutputLnF("","Title 2");               
        g_ooutfile.OutputLnF ("Модель верхнеуровневого описания бизнес-процесса","Caption"); 
        g_ooutfile.OutputLnF (DeleteNumSpaces(ParentGroup.Name(g_nloc)),"Caption");
        for (var i=0; i<14; i++) g_ooutfile.OutputLnF("","Title 2");                               
        g_ooutfile.OutputLnF("Минск","Title 3");             
        g_ooutfile.OutputLnF(__toString(new Date().getFullYear()),"Title 3");  
        g_ooutfile.EndSection(); 
        
        // Отрисовка содержания
        ToC(g_ooutfile);
        
        // Отрисовка основные термины и определения
        PortraitPage(true, g_ooutfile);
        Caption(true, 0, "Основные термины и определения", "Caption0", g_ooutfile); 
        
        // Ищем аббривиатуры во всех моделях выбранной группы
        // Правила:
        // 1. Строки бьются на слова по пробелам
        // 2. В словах игнорируются непечатные символы [:\(\)«»\.,;'"'] и сами слова с вхождением любых цифр
        // 3. Аббривиатура считаеться найденой если в слове встручаются две и более букв в верхнем регистре
        var ReasonOfContinue = false;
        for (var i = 0 ; i < DocumentStructure.length; i++ ){
            CurrentGroup = DocumentStructure[i][0];
            ArrayOfModels = CurrentGroup.ModelList(); // собираем все модели из текущей группы 
            if (ArrayOfModels.length > 0) { 
            
                for (var j = 0 ; j < ArrayOfModels.length; j++ ){ // и смотрим есть ли среди них врехнеуровневая модель
                    if (ArrayOfModels[j].TypeNum() == Constants.MT_VAL_ADD_CHN_DGM  && ArrayOfModels[j].Name(g_nloc).startsWith("3. Основные")) {
                        ModelOfOccurrence = ArrayOfModels[j]; 
                        isULDModel = true;
                        ReasonOfContinue = true;
                        break;
                    }  
                }  
            
                    if (isULDModel) { // если верхнеуровневая модель найдена, то получаем все остальные, необходимые модели
        
                    for (var j = 0 ; j < ArrayOfModels.length; j++ ){   
                        if (ArrayOfModels[j].TypeNum() == Constants.MT_MATRIX_MOD       && ArrayOfModels[j].Name(g_nloc).startsWith("Эксперты"))     ModelOfExperts      = ArrayOfModels[j];
                        if (ArrayOfModels[j].TypeNum() == Constants.MT_EEPC_TAB         && ArrayOfModels[j].Name(g_nloc).startsWith("Участники БП")) ModelOfMembers      = ArrayOfModels[j];
                        if (ArrayOfModels[j].TypeNum() == Constants.MT_VAL_ADD_CHN_DGM  && ArrayOfModels[j].Name(g_nloc).startsWith("3.2"))  ModelOfRelationship = ArrayOfModels[j];
                        if (ArrayOfModels[j].TypeNum() == Constants.MT_VAL_ADD_CHN_DGM  && ArrayOfModels[j].Name(g_nloc).startsWith("3.1"))  ModelOfStructure    = ArrayOfModels[j];
                    }
        
                    var ModelsList = [];
                    if (ModelOfOccurrence != null) ModelsList.push(ModelOfOccurrence);
                    if (ModelOfExperts != null) ModelsList.push(ModelOfExperts);
                    if (ModelOfMembers != null) ModelsList.push(ModelOfMembers);
                    if (ModelOfRelationship != null) ModelsList.push(ModelOfRelationship);
                    if (ModelOfStructure != null) ModelsList.push(ModelOfStructure);
            
                    if (ModelsList.length > 0) {
                         var OccsTextInModel = [];
                         for (var l = 0 ; l < ModelsList.length; l++ ){ 
                            var BPObjOcc = ModelsList[l].ObjOccList();
                            if (BPObjOcc.length > 0) {
                                for (var k = 0 ; k < BPObjOcc.length; k++ ){ 
                                    var ArrayOfOccsText = NameDescJoin(BPObjOcc[k]).split(" ");
                                    if (ArrayOfOccsText.length > 0) {
                                        for (var g = 0 ; g < ArrayOfOccsText.length; g++ ){ 
                                            OccsTextInModel.push(ArrayOfOccsText[g]); 
                                        }  
                                    }  
                                }
                            } 
                         }
                         
                         if (OccsTextInModel.length > 0) {
                            for (var l = 0 ; l < OccsTextInModel.length; l++ ){   
                                var ReplacedString = OccsTextInModel[l].replace(/[:\(\)«»\.,;'"']/g, "");
                                if (ReplacedString.match(/\d/g) == null) {
                                    var CompareResult = ReplacedString.match(/[А-ЯA-Z]/g);
                                    if (CompareResult != null && CompareResult.length > 1) ABBRList.push(ReplacedString);
                                }
                            }
                         }
                    }
                }
            }
        }
        
        if (!ReasonOfContinue) {        
            Dialogs.MsgBox("Не найдено ни одного верхнеуровневого описания в выбранной группе (подгруппах) !",  Constants.MSGBOX_ICON_INFORMATION | Constants.MSGBOX_BTN_OK, "BAPB_Верхнеуровневое описание БП");
            Context.setScriptError(Constants.ERR_CANCEL);
        }

        ABBRList = ArisData.Unique(ABBRList);
        ABBRList.sort();
        for (var i = 0 ; i < ABBRList.length; i++ ) {
            g_ooutfile.OutputLnF(ABBRList[i] + " –", "Regular");   
        }

        for (var i = 0 ; i < DocumentStructure.length; i++ ){
            CurrentGroup = DocumentStructure[i][0];
            isULDModel = false;
            ArrayOfModels = CurrentGroup.ModelList(); // собираем все модели из текущей группы 
            if (ArrayOfModels.length > 0) {
                
                // обнуляем переменные моделей, для последующего поиска и обработки их в случае если поиск удачен
                ModelOfOccurrence = null;
                ModelOfExperts = null;
                ModelOfMembers = null;
                ModelOfRelationship = null;
                ModelOfStructure = null;
                
                for (var j = 0 ; j < ArrayOfModels.length; j++ ){ // и смотрим есть ли среди них врехнеуровневая модель
                    if (ArrayOfModels[j].TypeNum() == Constants.MT_VAL_ADD_CHN_DGM  && ArrayOfModels[j].Name(g_nloc).startsWith("3. Основные")) {
                        ModelOfOccurrence = ArrayOfModels[j]; 
                        isULDModel = true;
                        break;
                    }  
                }    
                
                if (isULDModel) { // если верхнеуровневая модель найдена, то получаем все остальные, необходимые модели
                    for (var j = 0 ; j < ArrayOfModels.length; j++ ){   
                        if (ArrayOfModels[j].TypeNum() == Constants.MT_MATRIX_MOD       && ArrayOfModels[j].Name(g_nloc).startsWith("Эксперты"))     ModelOfExperts      = ArrayOfModels[j];
                        if (ArrayOfModels[j].TypeNum() == Constants.MT_EEPC_TAB         && ArrayOfModels[j].Name(g_nloc).startsWith("Участники БП")) ModelOfMembers      = ArrayOfModels[j];
                        if (ArrayOfModels[j].TypeNum() == Constants.MT_VAL_ADD_CHN_DGM  && ArrayOfModels[j].Name(g_nloc).startsWith("3.2"))  ModelOfRelationship = ArrayOfModels[j];
                        if (ArrayOfModels[j].TypeNum() == Constants.MT_VAL_ADD_CHN_DGM  && ArrayOfModels[j].Name(g_nloc).startsWith("3.1"))  ModelOfStructure    = ArrayOfModels[j];
                    }   
                    
                    Indent.value = DocumentStructure[i][1];
                    FontStyle = "Caption" + __toString(Indent.value); // задаем отступы для заголовков
                    FontStyleModels = "SmallCaption" + __toString(Indent.value+1); // задаем отступы для разделов модели
                    BPObjOccOccur = ModelOfOccurrence.ObjOccListFilter(-1, Constants.ST_VAL_ADD_CHN_SML_1); // получаем экземпляр объекта БП на модели окружения 
                    NameOfBP =  DeleteNumSpaces(NameDescJoin(BPObjOccOccur[0])); // получаем наименование модели
                    CxnListOccur = BPObjOccOccur[0].Cxns(); // и его связи с остальными экземплярами объектов на данной модели
                    
                    // проверяем атрибут СМК модели
                    if (BPObjOccOccur.length > 0) isSMKModel = BPObjOccOccur[0].ObjDef().Attribute(Constants.AT_ISO9000_REL, g_nloc).GetValue(true);
                    
                    if (isSMKModel == 1) { // если модель СМК
                        
                        PortraitPage(true, g_ooutfile);
                        // буффер необходим для помещения всех заголовков на одной странице с моделью, в особенности если БП не СМК и начинается с 
                        // графической модели БП и новой секции, соответствующей заданной ориентации страницы
                        if (HeaderList.length > 0) { // выводим все накопившиеся родительские категории на этот же лист, где вывод модели СМК
                            for (var j = 0 ; j < HeaderList.length; j++ ) Caption(true, HeaderList[j][0], HeaderList[j][1], HeaderList[j][2], HeaderList[j][3]); 
                            HeaderList = []; // после вывода очищаем буффер заголовков
                        }
                        // выводим заголовок модели
                        Caption(true, Indent.value, NameOfBP, FontStyle, g_ooutfile); 
                        
//--------------------------------------------------------------------- 
// Цели БП                        
                        // Начало вывода "Цели БП"
                        TargetOfBP = []; // массив для целей БП
                        for (var l = 0 ; l < CxnListOccur.length; l++ ){ // перебираем все связи БП с объектам на модели окружения
                            // если связъ "Поддерживает" соединяет БП с объектом "Цель", то этот объект идет в работу
                            if (CxnListOccur[l].CxnDef().TypeNum() == Constants.CT_SUPP_3 && CxnListOccur[l].TargetObjOcc().ObjDef().TypeNum() == Constants.OT_OBJECTIVE) {                                
                                TargetOfBP.push(NameDescJoin(CxnListOccur[l].TargetObjOcc()));
                            }                         
                        } 
                        g_ooutfile.OutputLnF("Цель БП:", "Header");
                        if (TargetOfBP.length == 0) g_ooutfile.OutputLnF("–" + "\n", "Header"); 
                        if (TargetOfBP.length == 1) g_ooutfile.OutputLnF(TargetOfBP[0] + "\n", "Regular");
                        if (TargetOfBP.length >= 2) 
                            for (var k = 0 ; k < TargetOfBP.length; k++ ) g_ooutfile.OutputLnF((1+k)+ ". " + TargetOfBP[k] + "\n", "Regular") 
                        g_ooutfile.OutputLnF("", "Regular");
                        // Конец вывода "Цели БП"
                        
//--------------------------------------------------------------------- 
// Первичные входы БП                        
                        // Начало вывода "Первичные входы БП"
                        FirstIn = []; // массив для первичных входов
                        for (var l = 0 ; l < CxnListOccur.length; l++ ){ // перебираем все связи БП с объектам на модели окружения
                            // если связъ "Является входом для" соединяет БП с объектом "Пакет", то этот объект идет в работу
                            if (CxnListOccur[l].CxnDef().TypeNum() == Constants.CT_IS_INP_FOR && CxnListOccur[l].SourceObjOcc().ObjDef().TypeNum() == Constants.OT_PACK) {
                                FirstIn.push(NameDescJoin(CxnListOccur[l].SourceObjOcc()));
                            }
                        } 
                        g_ooutfile.OutputLnF("Первичные входы БП:", "Header"); 
                        if (FirstIn.length == 0) g_ooutfile.OutputLnF("–" + "\n", "Header"); 
                        if (FirstIn.length == 1) g_ooutfile.OutputLnF(FirstIn[0] + "\n", "Regular");
                        if (FirstIn.length >= 2) 
                            for (var k = 0 ; k < FirstIn.length; k++ ) g_ooutfile.OutputLnF((1+k)+ ". " + FirstIn[k] + "\n", "Regular")   
                        g_ooutfile.OutputLnF("", "Regular"); 
                        // Конец вывода "Первичные входы БП"
                        
//--------------------------------------------------------------------- 
// Первичные выходы БП                        
                        // Начало вывода "Первичные выходы БП"
                        FirstOut = []; // массив для первичных выходов
                        for (var l = 0 ; l < CxnListOccur.length; l++ ){ // перебираем все связи БП с объектам на модели окружения
                            // если связъ "Имеет на выходе" соединяет БП с объектом "Цель", то этот объект идет в работу
                            if (CxnListOccur[l].CxnDef().TypeNum() == Constants.CT_HAS_OUT && CxnListOccur[l].TargetObjOcc().ObjDef().TypeNum() == Constants.OT_PACK) {
                                FirstOut.push(NameDescJoin(CxnListOccur[l].TargetObjOcc()));
                            }
                        } 
                        g_ooutfile.OutputLnF("Первичные выходы БП:", "Header"); 
                        if (FirstOut.length == 0) g_ooutfile.OutputLnF("–" + "\n", "Header"); 
                        if (FirstOut.length == 1) g_ooutfile.OutputLnF(FirstOut[0] + "\n", "Regular");
                        if (FirstOut.length >= 2) 
                            for (var k = 0 ; k < FirstOut.length; k++ ) g_ooutfile.OutputLnF((1+k)+ ". " + FirstOut[k] + "\n", "Regular")   
                        g_ooutfile.OutputLnF("", "Regular"); 
                        // Конец вывода "Первичные выходы БП"
                        
//--------------------------------------------------------------------- 
                        
                        if (ModelOfRelationship != null) { // если модель взаимоотношений найдена, то обрабатываем ее
                            
                            BPObjOccRelat = BPObjOccOccur[0].ObjDef().OccListInModel(ModelOfRelationship); // Получаем экземпляр объекта БП на модели взаимосвязей
                            CxnListRelat = BPObjOccRelat[0].Cxns(); // и его связи с остальными экземплярами объектов на данной модели
                            
//--------------------------------------------------------------------- 
// Вторичные входы БП
                            
                            // Начало вывода "Вторичные входы БП"
                            g_ooutfile.OutputLnF("Вторичные входы БП:", "Header");
                            g_ooutfile.OutputLnF("", "Regular");
                            SecondIn = []; // массивдля вторичных входов
                            
                            // шапка таблицы
                            var colWidthList = new java.util.ArrayList(); colWidthList.add(40); colWidthList.add(30); colWidthList.add(30); 
                            g_ooutfile.BeginTable(100, colWidthList, Constants.C_BLACK, Constants.C_WHITE, Constants.FMT_JUSTIFY,0); // открываем таблицу 
                            g_ooutfile.TableRow(); // добавляем строку
                            g_ooutfile.TableRow(); // добавляем строку
                            g_ooutfile.TableCellF("Вторичные входы БП", 2,1,  "TableHat"); 
                            g_ooutfile.TableCellF("Поставщики", 1,2,  "TableHat"); 
                            g_ooutfile.TableCellF("БП", 1,1,  "TableHat");
                            g_ooutfile.TableCellF("Структурное подразделение, коллегиальный орган банка/заинтересованная сторона", 1,1,  "TableHat");
                      /*закоментировал Коваленко АМ по указанию руководителя 25/10/2019      
                           g_ooutfile.TableRow(); // добавляем строку
                           g_ooutfile.TableCellF("Долгосрочные программы и концепции развития банковского сектора", 1,1,  "Table");
                            g_ooutfile.TableCellF(" ", 1,1,  "Table");
                           g_ooutfile.TableCellF("–", 1,1,  "Table");
                            g_ooutfile.TableCellF("Внешние организации", 1,1,  "Table");
                            g_ooutfile.TableRow(); // добавляем строку
                            g_ooutfile.TableCellF("Пруденциальные требования:\nНПА, в том числе НБ РБ; ТНПА", 1,1,  "Table");
                           g_ooutfile.TableCellF(" ", 1,1,  "Table");
                            g_ooutfile.TableCellF("–", 1,1,  "Table");
                            g_ooutfile.TableCellF("Внешние организации", 1,1,  "Table");
                        */    
                            var RelatPack = [];
                            for (var l = 0 ; l < CxnListRelat.length; l++ ){ // перебираем все связи БП с объектам на модели взаимосвязей
                                // если связъ "Является входом для" соединяет БП с объектом "Пакет", то этот объект идет в работу
                                if (CxnListRelat[l].CxnDef().TypeNum() == Constants.CT_IS_INP_FOR && CxnListRelat[l].SourceObjOcc().ObjDef().TypeNum() == Constants.OT_PACK) 
                                    RelatPack.push(CxnListRelat[l].SourceObjOcc());
                            }
                                
                            RelatPack = ArisData.sort(RelatPack, SortType1, SortType2, g_nloc);    

                            var EmptyTable = true; // флаг пустой таблицы для добавления дополнительной пустой строки к шапке
                            for (var l = 0 ; l < RelatPack.length; l++ ){ // перебираем все связи БП с объектам на модели взаимосвязей
                                // если связъ "Является входом для" соединяет БП с объектом "Пакет", то этот объект идет в работу
                                    var CxnOfPack = []; // массив для связей объекта "Пакет"
                                    CxnOfPack = RelatPack[l].Cxns(); // получаем связи                                 
                                    if (CxnOfPack.length > 0) {
                                        for (var u = 0 ; u < CxnOfPack.length; u++ ){ // перебираем все связи объекта "Пакет"
                                            // если связъ "Имеет на выходе" соединяет объект "Пакет" с объектом "Цепь сздания добавленной стоимости", то этот объект идет в работу
                                            if (CxnOfPack[u].CxnDef().TypeNum() == Constants.CT_HAS_OUT && (CxnOfPack[u].SourceObjOcc().SymbolNum() == Constants.ST_VAL_ADD_CHN_SML_1 || CxnOfPack[u].SourceObjOcc().SymbolNum() == Constants.ST_VAL_ADD_CHN_SML_2)) {
                                                var Cell2 = []; // массив для БП-поставщиков
                                                var Cell3 = []; // массив для Владельца этого БП
                                                var Cell2String = CxnOfPack[u].SourceObjOcc().ObjDef().Name(g_nloc).trim();                                                
                                                var CheckSMKAttr = CxnOfPack[u].SourceObjOcc().ObjDef().Attribute(Constants.AT_ISO9000_REL, g_nloc).GetValue(true);
                                                if (CheckSMKAttr != 1) Cell2String += "*"; // если у объекта БП не проставлен атрибут СМК, то помечаем звездочкой
                                                Cell2.push(Cell2String);
                                                
                                                // если БП не является собирательной категорией для других БП
                                                if (CxnOfPack[u].SourceObjOcc().SymbolNum() == Constants.ST_VAL_ADD_CHN_SML_1) {
                                                    var CxnOfBPTarget = []; // получаем все его связи
                                                    // если у объекта БП имеется связъ "является владельцем", то получаем информацию о владельце
                                                    CxnOfBPTarget = CxnOfPack[u].SourceObjOcc().ObjDef().CxnListFilter(Constants.EDGES_INOUT, Constants.CT_DECD_ON);
                                                    if (CxnOfBPTarget.length > 0) {
                                                        for (var p = 0 ; p < CxnOfBPTarget.length; p++ ){
                                                            Cell3.push(CxnOfBPTarget[p].SourceObjDef().Name(g_nloc).trim());        
                                                        }
                                                    }
                                                }
                                                
                                                // если БП является собирательной категорией для других БП
                                                if (CxnOfPack[u].SourceObjOcc().SymbolNum() == Constants.ST_VAL_ADD_CHN_SML_2) {
                                                    var DefsOfBPTarget = []; // массив для подчиненных БП
                                                    var StructUnits = []; // массив для структурных подразделений - владельцев БП
                                                    // получем все объекты "функции" связанные с БП исходящей связью "подчиняет по процессу"
                                                    DefsOfBPTarget = CxnOfPack[u].SourceObjOcc().ObjDef().getConnectedObjs([Constants.OT_FUNC],Constants.EDGES_OUT, [Constants.CT_IS_PRCS_ORNT_SUPER]);    
                                                    if (DefsOfBPTarget.length > 0) {
                                                        for (var h = 0 ; h < DefsOfBPTarget.length; h++ ){ // перебераем все полученные объекты
                                                            var CxnOfBPTarget = []; // получаем все связи
                                                            // если у объекта БП имеется связъ "является владельцем", то получаем информацию о владельце
                                                            CxnOfBPTarget = DefsOfBPTarget[h].CxnListFilter(Constants.EDGES_INOUT, Constants.CT_DECD_ON);
                                                            if (CxnOfBPTarget.length > 0) {
                                                                for (var p = 0 ; p < CxnOfBPTarget.length; p++ ){
                                                                    StructUnits.push(CxnOfBPTarget[p].SourceObjDef());
                                                                }   
                                                            }
                                                        }   
                                                    }
                                                    // если имеются дубликаты, то убираем их
                                                    //StructUnits = ArisData.Unique(StructUnits);
                                                    if (StructUnits.length > 0) { // если что-то найдено, то заполняем массив для вывода в третий столбец таблицы
                                                        for (var p = 0 ; p < StructUnits.length; p++ ){
                                                            Cell3.push(StructUnits[p].Name(g_nloc).trim()); 
                                                        }
                                                    }
                                                }                                                
                                                EmptyTable = false; 
                                                g_ooutfile.TableRow(); // добавляем строку
                                                g_ooutfile.TableCellF(NameDescJoin(RelatPack[l]), 1,1,  "Table");
                                                g_ooutfile.TableCellF(Cell2.sort().join('\n'), 1,1,  "Table");
                                                Cell3 = ArisData.Unique(Cell3);
                                                g_ooutfile.TableCellF(Cell3.sort().join('\n'), 1,1,  "Table");
                                            }
                                        }
                                    }
                            } 
                            
                            if (EmptyTable) { // если таблица пустая добовляем пустую строку к шапке
                                g_ooutfile.TableRow(); // добавляем строку
                                g_ooutfile.TableCellF("", 1,1,  "Table");
                                g_ooutfile.TableCellF("", 1,1,  "Table");
                                g_ooutfile.TableCellF("", 1,1,  "Table");
                            }
                            g_ooutfile.TableRow(); // добавляем строку
                            g_ooutfile.TableCellF("* бизнес-процессы верхнего уровня Модели (дерева) бизнес-процессов банка, не входящие в область СМК", 1,4,  "Table");
                            // закрыли таблицу
                            g_ooutfile.EndTable("",100, "Arial",11,Constants.C_BLACK,Constants.C_TRANSPARENT,0,Constants.FMT_LEFT | Constants.FMT_JUSTIFY,0);
                            g_ooutfile.OutputLnF("", "Header");
                            // Конец вывода "Вторичные входы БП"
    
//---------------------------------------------------------------------                            
// Вторичные выходы БП    
                            // Начало вывода "Вторичные выходы БП"
                            g_ooutfile.OutputLnF("Вторичные выходы БП:", "Header");
                            g_ooutfile.OutputLnF("", "Regular");
                            SecondOut = []; // массивдля вторичных входов
                            
                            // шапка таблицы
                            var colWidthList = new java.util.ArrayList(); colWidthList.add(40); colWidthList.add(30); colWidthList.add(30); 
                            g_ooutfile.BeginTable(100, colWidthList, Constants.C_BLACK, Constants.C_WHITE, Constants.FMT_JUSTIFY,0); // открываем таблицу   
                            g_ooutfile.TableRow(); // добавляем строку
                            g_ooutfile.TableRow(); // добавляем строку
                            g_ooutfile.TableCellF("Вторичные выходы БП", 2,1,  "TableHat"); 
                            g_ooutfile.TableCellF("Потребители", 1,2,  "TableHat"); 
                            g_ooutfile.TableCellF("БП", 1,1,  "TableHat");
                            g_ooutfile.TableCellF("Структурное подразделение, коллегиальный орган банка/заинтересованная сторона", 1,1,  "TableHat");
    
    
                            var RelatPack = [];
                            for (var l = 0 ; l < CxnListRelat.length; l++ ){ // перебираем все связи БП с объектам на модели взаимосвязей
                                // если связъ "Является входом для" соединяет БП с объектом "Пакет", то этот объект идет в работу
                                if (CxnListRelat[l].CxnDef().TypeNum() == Constants.CT_HAS_OUT && CxnListRelat[l].TargetObjOcc().ObjDef().TypeNum() == Constants.OT_PACK) 
                                    RelatPack.push(CxnListRelat[l].TargetObjOcc());
                            }
                                
                            RelatPack = ArisData.sort(RelatPack, SortType1, SortType2, g_nloc);     
    
    
                            var EmptyTable = true;
                            for (var l = 0 ; l < RelatPack.length; l++ ){ // перебираем все связи БП с объектам на модели взаимосвязей
                                // если связъ "имеет на выходе" соединяет БП с объектом "Пакет", то этот объект идет в работу
                                    var CxnOfPack = []; // массив для связей объекта "Пакет"
                                    CxnOfPack = RelatPack[l].Cxns();                                    
                                    if (CxnOfPack.length > 0) {
                                        for (var u = 0 ; u < CxnOfPack.length; u++ ){ // перебираем все связи объекта "Пакет"
                                            // если связъ "является входом для" соединяет объект "Пакет" с объектом БП, то этот объект идет в работу
                                            if (CxnOfPack[u].CxnDef().TypeNum() == Constants.CT_IS_INP_FOR && (CxnOfPack[u].TargetObjOcc().SymbolNum() == Constants.ST_VAL_ADD_CHN_SML_1 || CxnOfPack[u].TargetObjOcc().SymbolNum() == Constants.ST_VAL_ADD_CHN_SML_2)) {
                                                var Cell2 = []; // массив для БП-потребителей
                                                var Cell3 = []; // массив для Владельца этого БП
                                                var Cell2String = CxnOfPack[u].TargetObjOcc().ObjDef().Name(g_nloc).trim();
                                                var CheckSMKAttr = CxnOfPack[u].TargetObjOcc().ObjDef().Attribute(Constants.AT_ISO9000_REL, g_nloc).GetValue(true);
                                                if (CheckSMKAttr != 1) Cell2String += "*"; // если у объекта БП не проставлен атрибут СМК, то помечаем звездочкой
                                                Cell2.push(Cell2String);
                                                
                                                // если БП не является собирательной категорией для других подпроцессов
                                                if (CxnOfPack[u].TargetObjOcc().SymbolNum() == Constants.ST_VAL_ADD_CHN_SML_1) {
                                                    var CxnOfBPTarget = []; // получаем все его связи
                                                    // если у объекта БП имеется связъ "является владельцем", то получаем информацию о владельце
                                                    CxnOfBPTarget = CxnOfPack[u].TargetObjOcc().ObjDef().CxnListFilter(Constants.EDGES_INOUT, Constants.CT_DECD_ON);
                                                    if (CxnOfBPTarget.length > 0) {
                                                        for (var p = 0 ; p < CxnOfBPTarget.length; p++ ){
                                                            Cell3.push(CxnOfBPTarget[p].SourceObjDef().Name(g_nloc).trim());        
                                                        }
                                                    }
                                                }
                                                
                                                // если БП является собирательной категорией для других подпроцессов
                                                if (CxnOfPack[u].TargetObjOcc().SymbolNum() == Constants.ST_VAL_ADD_CHN_SML_2) {
                                                    var DefsOfBPTarget = []; // массив для подчиненных БП
                                                    var StructUnits = []; // массив для структурных подразделений - владельцев БП
                                                    // получем все объекты "функции" связанные с БП исходящей связью "подчиняет по процессу"
                                                    DefsOfBPTarget = CxnOfPack[u].TargetObjOcc().ObjDef().getConnectedObjs([Constants.OT_FUNC],Constants.EDGES_OUT, [Constants.CT_IS_PRCS_ORNT_SUPER]);    
                                                    if (DefsOfBPTarget.length > 0) {
                                                        for (var h = 0 ; h < DefsOfBPTarget.length; h++ ){ // перебераем все полученные объекты
                                                            var CxnOfBPTarget = []; // получаем все связи
                                                            // если у объекта БП имеется связъ "является владельцем", то получаем информацию о владельце
                                                            CxnOfBPTarget = DefsOfBPTarget[h].CxnListFilter(Constants.EDGES_INOUT, Constants.CT_DECD_ON);
                                                            if (CxnOfBPTarget.length > 0) {
                                                                for (var p = 0 ; p < CxnOfBPTarget.length; p++ ){
                                                                    StructUnits.push(CxnOfBPTarget[p].SourceObjDef());
                                                                }   
                                                            }
                                                        }   
                                                    }
                                                    // если имеются дубликаты, то убираем их
                                                    // StructUnits = ArisData.Unique(StructUnits);
                                                    if (StructUnits.length > 0) { // если что-то найдено, то заполняем массив для вывода в третий столбец таблицы
                                                        for (var p = 0 ; p < StructUnits.length; p++ ){
                                                            Cell3.push(StructUnits[p].Name(g_nloc).trim()); 
                                                        }
                                                    }
                                                }
                                                
                                                EmptyTable = false;
                                                g_ooutfile.TableRow(); // добавляем строку
                                                g_ooutfile.TableCellF(NameDescJoin(RelatPack[l]), 1,1,  "Table");
                                                g_ooutfile.TableCellF(Cell2.sort().join('\n'), 1,1,  "Table");
                                                Cell3 = ArisData.Unique(Cell3);
                                                g_ooutfile.TableCellF(Cell3.sort().join('\n'), 1,1,  "Table");
                                            }
                                        }
                                    }
                            } 
                            
                            if (EmptyTable) { // если таблица пустая добовляем пустую строку к шапке
                                g_ooutfile.TableRow(); // добавляем строку
                                g_ooutfile.TableCellF("", 1,1,  "Table");
                                g_ooutfile.TableCellF("", 1,1,  "Table");
                                g_ooutfile.TableCellF("", 1,1,  "Table");
                            }
                            
                            g_ooutfile.TableRow(); // добавляем строку
                            g_ooutfile.TableCellF("* бизнес-процессы верхнего уровня Модели (дерева) бизнес-процессов банка, не входящие в область СМК", 1,4,  "Table");
                            // закрыли таблицу
                            g_ooutfile.EndTable("",100, "Arial",11,Constants.C_BLACK,Constants.C_TRANSPARENT,0,Constants.FMT_LEFT | Constants.FMT_JUSTIFY,0);
                            g_ooutfile.OutputLnF("", "Header");
                            // Конец вывода "Вторичные выходы БП"
                        } // Конец работы с моделью взаимоотношений
                        
//---------------------------------------------------------------------    
// Ресурсы БП

                        // Начало вывода "Ресурсы БП"
                        g_ooutfile.OutputLnF("Ресурсы БП:", "Header");
                        g_ooutfile.OutputLnF("", "Regular");

                        // шапка таблицы
                        var colWidthList = new java.util.ArrayList(); colWidthList.add(35); colWidthList.add(35); colWidthList.add(30); 
                        g_ooutfile.BeginTable(100, colWidthList, Constants.C_BLACK, Constants.C_WHITE, Constants.FMT_JUSTIFY,0); // открываем таблицу  
                        g_ooutfile.TableRow(); // добавляем строку
                        g_ooutfile.TableRow(); // добавляем строку
                        g_ooutfile.TableCellF("Наименование ресурсов", 2,1,  "TableHat"); 
                        g_ooutfile.TableCellF("Поставщики", 1,2,  "TableHat"); 
                        g_ooutfile.TableCellF("БП", 1,1,  "TableHat");
                        g_ooutfile.TableCellF("Структурное подразделение, коллегиальный орган банка/заинтересованная сторона", 1,1,  "TableHat");

                        var EmptyTable = true;
                        /* наполняем таблицу
                        for (var l = 0 ; l < CxnListOccur.length; l++ ){ // перебираем все связи БП с объектам на модели взаимосвязей
                            // переменная CxnListOccur содержит все существующие связи объекта БП на модели окружения
                            // здесь должен быть прописан алгоритм заполнения таблицы 
                            // var EmptyTable = false;
                        } */
                        
                        if (EmptyTable) { // если таблица пустая добовляем пустую строку к шапке
                            g_ooutfile.TableRow(); // добавляем строку
                            g_ooutfile.TableCellF("", 1,1,  "TableHat"); 
                            g_ooutfile.TableCellF("", 1,1,  "TableHat");
                            g_ooutfile.TableCellF("", 1,1,  "TableHat"); 
                        }

                        // закрыли таблицу
                        g_ooutfile.EndTable("",100, "Arial",11,Constants.C_BLACK,Constants.C_TRANSPARENT,0,Constants.FMT_LEFT | Constants.FMT_JUSTIFY,0);
                        g_ooutfile.OutputLnF("", "Header");
                        // Конец вывода "Ресурсы БП"

//--------------------------------------------------------------------- 
// Оценка результативности БП     
                   
                        // Начало вывода "Оценка результативности БП"
                        g_ooutfile.OutputLnF("Оценка результативности БП:", "Header");
                        g_ooutfile.OutputLnF("", "Header");

                        // шапка таблицы
                        var colWidthList = new java.util.ArrayList(); colWidthList.add(40); colWidthList.add(22); colWidthList.add(19); colWidthList.add(19); 
                        g_ooutfile.BeginTable(100, colWidthList, Constants.C_BLACK, Constants.C_WHITE, Constants.FMT_JUSTIFY,0); // открываем таблицу  
                        
                        g_ooutfile.TableRow(); // добавляем строку
                        g_ooutfile.TableRow(); // добавляем строку
                        g_ooutfile.TableCellF("Наименование показателей БП, %", 2,1,  "TableHat"); 
                        g_ooutfile.TableCellF("Критерии результативности БП", 2,1,  "TableHat");
                        g_ooutfile.TableCellF("Период, ежегодно", 1,2,  "TableHat"); 
                        g_ooutfile.TableCellF("План", 1,1,  "TableHat");
                        g_ooutfile.TableCellF("Факт", 1,1,  "TableHat");

                        var EmptyTable = true;
                        for (var l = 0 ; l < CxnListOccur.length; l++ ){ // перебираем все связи БП с объектам на модели окружения
                            // если связъ "измеряется с помощью" соединяет БП с объектом "KPI", то этот объект идет в работу
                            if (CxnListOccur[l].CxnDef().TypeNum() == Constants.CT_MEASURED_BY && CxnListOccur[l].TargetObjOcc().ObjDef().TypeNum() == Constants.OT_KPI) {  
                                EmptyTable = false;
                                g_ooutfile.TableRow(); // добавляем строку
                                g_ooutfile.TableCellF(NameDescJoin(CxnListOccur[l].TargetObjOcc()), 1,1,  "Table"); 
                                g_ooutfile.TableCellF("Достижение плановых значений", 1,1,  "Table");
                                // получаем плановое значение из атрибута
                                var PlanVal = CxnListOccur[l].TargetObjOcc().ObjDef().Attribute(Constants.AT_PL_VAL,g_nloc).GetValue(true).toString();
                                if (PlanVal == "") g_ooutfile.TableCellF("Установленное значение", 1,1,  "Table"); // если атрибут не установлен выводим текст
                                else g_ooutfile.TableCellF(PlanVal, 1,1,  "Table");
                                // получаем фактическое значение из атрибута
                                var FactVal = CxnListOccur[l].TargetObjOcc().ObjDef().Attribute(Constants.AT_ACT_VAL,g_nloc).GetValue(true).toString();
                                if (FactVal == "") g_ooutfile.TableCellF("Фактическое значение за период", 1,1,  "Table"); // если атрибут не установлен выводим текст
                                else g_ooutfile.TableCellF(FactVal, 1,1,  "Table");    
                            }
                        } 
                        
                        if (EmptyTable) { // если таблица пустая добовляем пустую строку к шапке
                            g_ooutfile.TableRow(); // добавляем строку
                            g_ooutfile.TableCellF("", 1,1,  "TableHat"); 
                            g_ooutfile.TableCellF("", 1,1,  "TableHat");
                            g_ooutfile.TableCellF("", 1,1,  "TableHat"); 
                            g_ooutfile.TableCellF("", 1,1,  "TableHat"); 
                        }
                        
                        // закрыли таблицу
                        g_ooutfile.EndTable("",100, "Arial",11,Constants.C_BLACK,Constants.C_TRANSPARENT,0,Constants.FMT_LEFT | Constants.FMT_JUSTIFY,0);
                        g_ooutfile.OutputLnF("\n", "Header");
                        // Конец вывода "Оценка результативности БП"
                    } // end of isSMKModel
                    
//--------------------------------------------------------------------- 
                    
//--------------------------------------------------------------------- 
// Окружение бизнес-процесса

                    // Начало вывода графики "Окружение бизнес-процесса"
                    if (ModelOfOccurrence != null) { // если модель окружения найдена, то обрабатываем ее
                        if (isOuputPictures) CheckOrientation(ModelOfOccurrence);
                        if (isSMKModel != 1) { // если модель не СМК, то необходимо вывести заголовки, накопившиеся в буффере
                            // буффер необходим для помещения всех заголовков на одной странице с моделью, в особенности если БП не СМК и начинается с 
                            // графической модели БП и новой секции, соответствующей заданной ориентации страницы
                            if (HeaderList.length > 0) {
                                for (var j = 0 ; j < HeaderList.length; j++ ) Caption(true, HeaderList[j][0], HeaderList[j][1], HeaderList[j][2], HeaderList[j][3]); 
                                HeaderList = []; // после вывода очищаем буффер заголовков
                            }
                            Caption(true, Indent.value, NameOfBP, FontStyle, g_ooutfile); 
                        }
                        Caption(true, Indent.value+1, "Окружение бизнес-процесса", FontStyleModels, g_ooutfile); 
                        if (isOuputPictures) PaintPictures(ModelOfOccurrence, g_ooutfile);
                    }
                    // Конец вывода графики "Окружение бизнес-процесса"
                    
//---------------------------------------------------------------------        
                
//--------------------------------------------------------------------- 
// Структура бизнес-процесса

                    // Начало вывода графики "Структура бизнес-процесса"
                    if (ModelOfStructure != null) { // если модель структуры найдена, то обрабатываем ее
                        
                        if (isOuputPictures) CheckOrientation(ModelOfStructure);
                        Caption(false, Indent.value+1, "Структура бизнес-процесса", FontStyleModels, g_ooutfile); 
                        g_ooutfile.OutputLnF(NameOfBP, "RegularBold");

                        // Получаем экземпляр объекта БП на модели структуры
                        BPObjOccStruct = BPObjOccOccur[0].ObjDef().OccListInModel(ModelOfStructure);
                        if (isGeometryStruct) { // если структура должна выводиться по геометрии
                            var SubBPObjOccsStruct = ModelOfStructure.ObjOccListFilter(); // получаем все объекты на модели
                            SubBPObjOccsStruct = ArisData.sort( SubBPObjOccsStruct, SortType1, SortType2, g_nloc); // сортируем
                            for (var l = 0 ; l < SubBPObjOccsStruct.length; l++ ){ // выводим каждый объект по порядку кроме самого объекта БП
                                if (SubBPObjOccsStruct[l].ObjDef().GUID() != BPObjOccStruct[0].ObjDef().GUID()) {
                                    var indentlvl = DetectIndentFromNumber(SubBPObjOccsStruct[l]);
                                    g_ooutfile.OutputLnF(SubBPObjOccsStruct[l].ObjDef().Name(g_nloc), "Indent"+indentlvl);
                                }
                            }  
                        } else { // если структура должна выводиться по связям
                            var SubBPObjOccsThirdLvl = []; // массив для БП 3-го уровня
                            // получаем все функции соединенных исходящей связью с объектом БП
                            SubBPObjOccsThirdLvl = BPObjOccStruct[0].getConnectedObjOccs([Constants.ST_VAL_ADD_CHN_SML_1], Constants.EDGES_OUT);
                            if (SubBPObjOccsThirdLvl.length > 0) {
                                var isFind = false; 
                                var CxnSubBPObjOccsThirdLvl = []; // массив для связей БП n-го уровня
                                var SearchResult = []; // массив для результатов дриллдауна по объектам БП через определенную связь
                                for (var l = 0 ; l < SubBPObjOccsThirdLvl.length; l++ ){ // обрабатываем каждый объект БП n-го уровня
                                    SearchResult.push(SubBPObjOccsThirdLvl[l]); // добавляем данный объект в результатирующий массив
                                    var LastSerachObjOcc = SubBPObjOccsThirdLvl[l]; // задаем его в качестве начального для поиска по связям других БП 3-го уровня
                                    do {  // ищем пока находятся последующие БП 3-го уровня
                                        CxnLastSerachObjOcc = LastSerachObjOcc.Cxns(Constants.EDGES_OUT); // получаем перечень связей
                                        LastSerachObjOcc = null;
                                        isFind = false; // по умолчанию считаем что ничего не нашли
                                        if (CxnLastSerachObjOcc.length > 0) { 
                                            for (var k = 0 ; k < CxnLastSerachObjOcc.length; k++ ){ // перебераем все связи
                                                // если нашли объект соединенный с текущем БП третьего уровня связью "является предшественником"
                                                if (CxnLastSerachObjOcc[k].CxnDef().TypeNum() == Constants.CT_IS_PRCS_ORNT_SUPER) {
                                                    SearchResult.push(CxnLastSerachObjOcc[k].TargetObjOcc()); // добовляем найденный объект в результатирующий массив как БП 3-го уровня
                                                    if (LastSerachObjOcc == null) LastSerachObjOcc = CxnLastSerachObjOcc[k].TargetObjOcc(); // задаем его в качестве начального для поиска по связям других БП 3-го уровня
                                                    else SubBPObjOccsThirdLvl.push(CxnLastSerachObjOcc[k].TargetObjOcc()); // если найден еще БП 3-го уровня, а следующий объект поиска уже задан, то ставим поиск в очередь
                                                    isFind = true; // ставим флаг продолжения поиска
                                                }
                                            }
                                        }                                
                                    } while (isFind)     
                                }
                                
                                SearchResult = ArisData.Unique(SearchResult);
                                SubBPObjOccsThirdLvl = SearchResult; // присваеваем все найденные БП n-го уровня обратно соответствующему массиву
                                SubBPObjOccsThirdLvl = ArisData.sort(SubBPObjOccsThirdLvl, SortType1, SortType2, g_nloc);

                                for (var l = 0 ; l < SubBPObjOccsThirdLvl.length; l++ ){ // обрабатываем каждый БП 3-го уровня
                                    // выводим в отчет БП 3-го уровня
                                    
                                    var indentlvl = DetectIndentFromNumber(SubBPObjOccsThirdLvl[l]);
                                    g_ooutfile.OutputLnF(SubBPObjOccsThirdLvl[l].ObjDef().Name(g_nloc), "Indent"+indentlvl);    
                            /*      var SubBPObjOccsFourthLvl = []; // массив для БП 4-го уровня
                                    var CnxSubBPObjOccsFourthLvl = []; // массив для связей БП 4-го уровня
                                    CnxSubBPObjOccsFourthLvl = SubBPObjOccsThirdLvl[l].Cxns(Constants.EDGES_OUT); // получаем связи
                                    if (CnxSubBPObjOccsFourthLvl.length > 0) {
                                        for (var k = 0 ; k < CnxSubBPObjOccsFourthLvl.length; k++ ){ // обрабатываем каждую связь
                                            // если БП третьего уровня имеет связь "подчиняет по процессу", то целевой объект считаем БП 4-го уровня
                                            if (CnxSubBPObjOccsFourthLvl[k].CxnDef().TypeNum() == Constants.CT_IS_PRCS_ORNT_SUPER)    
                                            SubBPObjOccsFourthLvl.push(CnxSubBPObjOccsFourthLvl[k].TargetObjOcc());
                                        }
                                        if (SubBPObjOccsFourthLvl.length > 0) { // если нашли БП 4-го уровня
                                            SubBPObjOccsFourthLvl = ArisData.sort(SubBPObjOccsFourthLvl, SortType1, SortType2, g_nloc);
                                            // выводим их в отчет
                                            for (var h = 0 ; h < SubBPObjOccsFourthLvl.length; h++ ) g_ooutfile.OutputLnF(SubBPObjOccsFourthLvl[h].ObjDef().Name(g_nloc), "Indent1");          
                                        }
                                    } */
                                } 
                            
                            }
                        }
                        g_ooutfile.OutputLnF("","Regular");
                        if (isOuputPictures) PaintPictures(ModelOfStructure, g_ooutfile); 
                    }
                    // Конец вывода графики "Структура бизнес-процесса" 
//---------------------------------------------------------------------                   
                
//--------------------------------------------------------------------- 
// Участники бизнес-процесса

                    // Начало вывода графики "Участники бизнес-процесса"
                    if (ModelOfMembers != null) { // если модель участников найдена, то обрабатываем ее
                        if (isOuputPictures) CheckOrientation(ModelOfMembers);
                        Caption(true, Indent.value+1, "Участники бизнес-процесса", FontStyleModels, g_ooutfile);                        
                        if (isOuputPictures) PaintPictures(ModelOfMembers, g_ooutfile); 
                    }
                    // Конец вывода графики "Участники бизнес-процесса"
                    
//---------------------------------------------------------------------

//--------------------------------------------------------------------- 
// Эксперты БП

                    // Начало вывода графики "Эксперты БП"
                    if (ModelOfExperts != null) { // если модель експертов найдена, то обрабатываем ее
                        if (isOuputPictures == true) CheckOrientation(ModelOfExperts);
                        Caption(true, Indent.value+1, "Эксперты бизнес-процесса", FontStyleModels, g_ooutfile); 
                        if (isOuputPictures) PaintPictures(ModelOfExperts, g_ooutfile); 
                    }
                    // Конец вывода графики "Эксперты БП"
                    
//---------------------------------------------------------------------            
                
//--------------------------------------------------------------------- 
// Взаимосвязь БП

                    // Начало вывода графики "Взаимосвязь БП"
                    if (ModelOfRelationship != null) { // если модель взаимосвязей найдена, то обрабатываем ее
                        if (isOuputPictures == true) CheckOrientation(ModelOfRelationship);
                        Caption(true, Indent.value+1, "Взаимосвязь бизнес-процесса", FontStyleModels, g_ooutfile); 
                        if (isOuputPictures) PaintPictures(ModelOfRelationship, g_ooutfile); 
                    }
                    // Конец вывода графики "Эксперты БП"
                    
//--------------------------------------------------------------------- 
                    
//--------------------------------------------------------------------- 
// Сбор информации для сводных таблиц

                    // Собираем информацию о Экспертах и Владельцах
                    for (var l = 0 ; l < CxnListOccur.length; l++ ){ // перебираем каждую связь объекта БП на модели окружения
                        // если связъ "является экспертом" соединяет БП с объектом "Организационная единица", то работаем с ним 
                        if (CxnListOccur[l].CxnDef().TypeNum() == Constants.CT_HAS_CONSLT_ROLE_IN_1 && CxnListOccur[l].SourceObjOcc().ObjDef().TypeNum() == Constants.OT_ORG_UNIT) {
                            var Index = indexOf(ListOfExperts,CxnListOccur[l].SourceObjOcc().ObjDef().Name(g_nloc));
                            // если этот експерт уже присутствует в списке, то просто наполняем список его БП
                            // в другом случае добавляем и эксперта, и наименование БП
                            if (Index >= 0) ListOfExperts[Index][1] = ListOfExperts[Index][1] + "|" + NameOfBP;
                            else ListOfExperts.push(new Array(CxnListOccur[l].SourceObjOcc().ObjDef().Name(g_nloc), NameOfBP)); 
                        }
                        // если связъ "является владельцем" соединяет БП с объектом "Тип лица", то работаем с ним 
                        if (CxnListOccur[l].CxnDef().TypeNum() == Constants.CT_DECD_ON && CxnListOccur[l].SourceObjOcc().ObjDef().TypeNum() == Constants.OT_PERS_TYPE) {
                            var Index = indexOf(ListOfOwners,CxnListOccur[l].SourceObjOcc().ObjDef().Name(g_nloc));
                            // если этот владелец уже присутствует в списке, то просто наполняем список его БП
                            // в другом случае добавляем и владельца, и наименование БП
                            if (Index >= 0) ListOfOwners[Index][1] = ListOfOwners[Index][1] + "|" + NameOfBP;
                            else ListOfOwners.push(new Array(CxnListOccur[l].SourceObjOcc().ObjDef().Name(g_nloc), NameOfBP)); 
                        }                            
                    } 
                } // end of isULDModel
                
//---------------------------------------------------------------------  

            } else {
                
                // если не найдена модель окружения в текущей группе
                // то необходимо проверить ее наличие во всех подгруппах данной группы
                var ModelsOfChildsGroup = CurrentGroup.ModelList (true, [Constants.MT_VAL_ADD_CHN_DGM]);
                if (ModelsOfChildsGroup.length > 0) { 
                    for (var l = 0 ; l < ModelsOfChildsGroup.length; l++ ){ 
                        // если найдена внутри модель окружения, то необходимо вывести данный заголовок в документ
                        // помещаем заголовок в буффер заголовков, который необходим для отображения всех собранных заголовков 
                        // на одной странице с моделью, в особенности если БП не СМК и начинается с графической модели БП и 
                        // новой секции, соответствующей заданной ориентации страницы
                        if (ModelsOfChildsGroup[l].Name(g_nloc).startsWith("_Окружение")) {
                            Indent.value = DocumentStructure[i][1];
                            FontStyle = "Caption" + __toString(Indent.value);
                            NameOfGroup =  DeleteNumSpaces(CurrentGroup.Name(g_nloc));
                            HeaderList.push(new Array(Indent.value, NameOfGroup, FontStyle, g_ooutfile));
                            break;
                        }
                    }       
                }
            } 
        } // Конец перебора подгрупп выбранной группы
        
//---------------------------------------------------------------------   
// Сводная таблица по Экспертам
        
        PortraitPage(true, g_ooutfile);
        // Начало вывода сводной таблицы по Экспертам
        if (ListOfExperts.length > 0) {
            Caption(true, 0, "Сводная таблица экспертов БП", "Caption0", g_ooutfile);
            ListOfExperts.sort();
            // шапка таблицы
            g_ooutfile.BeginTable(100,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_LEFT | Constants.FMT_JUSTIFY | Constants.FMT_REPEAT_HEADER,0); // открываем таблицу   
            g_ooutfile.TableRow(); // добавляем строку
            g_ooutfile.TableCellF("Наименование структурного подразделения, являющегося экспертом бизнес-процессов", 35,  "TableHat"); 
            g_ooutfile.TableCellF("Наименование бизнес-процесса, для которого структурное подразделение является экспертом", 65,  "TableHat"); 
//OS20180320---------------------------------------------------  
            // нумерация БП эксперта
            for (var i = 0 ; i < ListOfExperts.length; i++ ) {
                var NumArray = ListOfExperts[i][1].split("|");
                if (NumArray.length > 1) {
                    ListOfExperts[i][1] = "";
                    for (var l = 0 ; l < NumArray.length; l++ ) {
                        if (ListOfExperts[i][1] == "") ListOfExperts[i][1] = (l+1) + ") " + NumArray[l];   
                        else ListOfExperts[i][1] = ListOfExperts[i][1] + "\n" + (l+1) + ") " + NumArray[l];   
                    }
                }
                
            }
//-------------------------------------------------------------      
            // вывод эксперта и его БП
            for (var i = 0 ; i < ListOfExperts.length; i++ ) {
                g_ooutfile.TableRow(); // добавляем строку
                g_ooutfile.TableCellF(ListOfExperts[i][0], 35,  "TableCenter"); 
                g_ooutfile.TableCellF(ListOfExperts[i][1], 65,  "Table"); 
            }
    
            // закрыли таблицу
            g_ooutfile.EndTable("",100, "Arial",11,Constants.C_BLACK,Constants.C_TRANSPARENT,0,Constants.FMT_LEFT | Constants.FMT_JUSTIFY,0);
            g_ooutfile.OutputLnF("\n", "Header");
            
        }
        // Конец вывода сводной таблицы по Экспертам
        
//---------------------------------------------------------------------   
    
//---------------------------------------------------------------------   
// Сводная таблица по Владельцам        
        
        // Начало вывода сводной таблицы по Владельцам
        if (ListOfOwners.length > 0) {
            Caption(true, 0, "Сводная таблица владельцев БП", "Caption0", g_ooutfile);
            ListOfOwners.sort();
            // шапка таблицы
            g_ooutfile.BeginTable(100,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_LEFT | Constants.FMT_JUSTIFY | Constants.FMT_REPEAT_HEADER,0); // открываем таблицу   
            g_ooutfile.TableRow(); // добавляем строку
            g_ooutfile.TableCellF("Владелец бизнес-процесса", 35,  "TableHat"); 
            g_ooutfile.TableCellF("Наименование бизнес-процесса", 65,  "TableHat"); 
//OS20180320---------------------------------------------------  
            // нумерация БП владельца
            for (var i = 0 ; i < ListOfOwners.length; i++ ) {
                var NumArray = ListOfOwners[i][1].split("|");
                if (NumArray.length > 1) {
                    ListOfOwners[i][1] = "";
                    for (var l = 0 ; l < NumArray.length; l++ ) {
                        if (ListOfOwners[i][1] == "") ListOfOwners[i][1] = (l+1) + ") " + NumArray[l];   
                        else ListOfOwners[i][1] = ListOfOwners[i][1] + "\n" + (l+1) + ") " + NumArray[l];   
                    }
                } 
            }
//-------------------------------------------------------------              
            // вывод владельца и  его БП
            for (var i = 0 ; i < ListOfOwners.length; i++ ) {
                g_ooutfile.TableRow(); // добавляем строку
                g_ooutfile.TableCellF(ListOfOwners[i][0], 35,  "TableCenter"); 
                g_ooutfile.TableCellF(ListOfOwners[i][1], 65,  "Table"); 
            }
    
            // закрыли таблицу
            g_ooutfile.EndTable("",100, "Arial",11,Constants.C_BLACK,Constants.C_TRANSPARENT,0,Constants.FMT_LEFT | Constants.FMT_JUSTIFY,0);
            g_ooutfile.OutputLnF("\n", "Header");
            
        }
        // Конец вывода сводной таблицы по Владельцам   
    } 
}

//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Отрисовка нижнего колонтитула
function Footer(g_ooutfile) 
{
    var image = undefined;
    g_ooutfile.BeginFooter();
    g_ooutfile.BeginTable(100,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_CENTER,0);
    g_ooutfile.TableRow();
    g_ooutfile.TableCellF("",35,"Footer");
    image = Context.createPicture("LogoAPB.jpg");
    g_ooutfile.OutGraphic(image,-1,30,30);
    g_ooutfile.TableCellF("",35,"Footer");
    g_ooutfile.BeginParagraph(Constants.FMT_CENTER,0,0,0,0,0);
    g_ooutfile.OutputF("© ОАО «Белагропромбанк»","Footer");
    g_ooutfile.EndParagraph();
    g_ooutfile.TableCellF("",30,"Footer");
    g_ooutfile.BeginParagraph(Constants.FMT_CENTER,0,0,0,0,0);
    g_ooutfile.OutputF("Стр.","Footer");
    g_ooutfile.OutputField(Constants.FIELD_PAGE,"Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_CENTER);
    g_ooutfile.OutputF(" из ","Footer");
    g_ooutfile.OutputField(Constants.FIELD_NUMPAGES,"Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_CENTER);
    g_ooutfile.EndParagraph();
    g_ooutfile.EndTable("",100,"Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,0,Constants.FMT_CENTER,0);
    g_ooutfile.EndFooter();
}
//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Разметка страницы для альбомного(ландшафтного) вида и открытие соответствующих секций документа
function LandscapePage(beginsection, g_ooutfile) 
{
    if (beginsection == true) {
        if (isOpenSection) g_ooutfile.EndSection();
        g_ooutfile.BeginSection(false, Constants.SECTION_DEFAULT); 
        isOpenSection = true;
    }
    g_ooutfile.SetPageWidth(297);	 
    g_ooutfile.SetPageHeight(210);
    g_ooutfile.SetLeftMargin(20);
    g_ooutfile.SetRightMargin(20);
    g_ooutfile.SetTopMargin(30);
    g_ooutfile.SetBottomMargin(10);
    g_ooutfile.SetDistFooter(10);
    PicW = 257;
    PicH = 150;
    // Выводим нижный колонтитул
    Footer(g_ooutfile); 
}

// Разметка страницы для книжного(портретного) вида и открытие соответствующих секций документа
function PortraitPage(beginsection, g_ooutfile) 
{ 
    if (beginsection == true) {
        if (isOpenSection) g_ooutfile.EndSection();
        g_ooutfile.BeginSection(false, Constants.SECTION_DEFAULT); 
        isOpenSection = true;
    }
    g_ooutfile.SetPageWidth(210);	 
    g_ooutfile.SetPageHeight(297);
    g_ooutfile.SetLeftMargin(30);
    g_ooutfile.SetRightMargin(10);
    g_ooutfile.SetTopMargin(20);
    g_ooutfile.SetBottomMargin(20);
    g_ooutfile.SetDistFooter(10);
    PicW = 165;
    PicH = 240;
    // Выводим нижный колонтитул
    Footer(g_ooutfile);  
} 
//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Отрисовка содержания
function ToC(g_ooutfile) 
{
    g_ooutfile.BeginSection(false, Constants.SECTION_INDEX);
    Footer(g_ooutfile);
    g_ooutfile.SetAutoTOCNumbering(false);
    for (var i=0; i<7; i++) g_ooutfile.SetTOCFormat(i, "Times New Roman", 10 , Constants.C_BLACK, Constants.C_WHITE, Constants.FMT_LEFT, i*3, 0, 0, 0);
    g_ooutfile.OutputLn("Содержание", "Times New Roman",12,Constants.C_BLACK,Constants.C_TRANSPARENT,Constants.FMT_BOLD | Constants.FMT_LEFT,0);
    g_ooutfile.OutputField(Constants.FIELD_TOC, "Times New Roman",10, Constants.C_BLACK, Constants.C_WHITE, Constants.FMT_LEFT);
    g_ooutfile.EndSection();  
}
//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Определение структуры подгрупп выбранной группы и определение отступов в соответствии с данной структурой
// используется для построения структуры документа
function DetectStructure(ParentGroup, Indent, DocumentStructure)
{
    var ChildGroups = null;
    for (var i = 0 ; i < ParentGroup.length; i++ ){
        var CurrentGroup = ParentGroup[i];
        ChildGroups = [];      
        ChildGroups = ParentGroup[i].Childs(false);
        ChildGroups = __sort(ChildGroups, Constants.AT_NAME, g_nloc);
        DocumentStructure.push(new Array(CurrentGroup,Indent.value));
        if (ChildGroups.length > 0) {
            DetectStructureChilds(ChildGroups, new __holder(Indent.value + 1), DocumentStructure);
        }
    }
}

function DetectStructureChilds(ChildGroups, Indent, DocumentStructure)
{
    var CurrentGroup = new __holder(null);
    var ChildGroupsSub = []; 
    for (var i = 0 ; i < ChildGroups.length; i++ ){
        CurrentGroup = ChildGroups[i];
        ChildGroupsSub = []; 
        ChildGroupsSub = CurrentGroup.Childs(false);
        ChildGroupsSub = __sort(ChildGroupsSub, Constants.AT_NAME, g_nloc);
        DocumentStructure.push(new Array(CurrentGroup,Indent.value));
        if (ChildGroupsSub.length > 0) {
            DetectStructure(ChildGroupsSub, new __holder(Indent.value + 1), DocumentStructure);
        }
    }
}

//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Вывод заголовков документа и, при необходимости, проставление нумерации
function Caption(Spacing, ncurrentdepth, NameOfGroup, headertype, g_ooutfile) 
{            
    if (isTOCNumbering) {         
         switch (ncurrentdepth) {
            case 0: 
                TOCnumLev[0]++;
                for (var k = 1 ; k < TOCnumLev.length; k++ ) TOCnumLev[k] = 0;
                g_ooutfile.OutputLnF(TOCnumLev[0] + ". " + NameOfGroup, headertype); 
                break;
            case 1: 
                TOCnumLev[1]++;
                for (var k = 2 ; k < TOCnumLev.length; k++ ) TOCnumLev[k] = 0;
                g_ooutfile.OutputLnF(TOCnumLev[0] + "." + TOCnumLev[1] + ". " + NameOfGroup, headertype);                     
                break;
            case 2: 
                TOCnumLev[2]++;
                for (var k = 3 ; k < TOCnumLev.length; k++ ) TOCnumLev[k] = 0;
                g_ooutfile.OutputLnF(TOCnumLev[0] + "." + TOCnumLev[1] + "." + TOCnumLev[2] + ". " + NameOfGroup, headertype);                     
                break;                
            case 3: 
                TOCnumLev[3]++;
                for (var k = 4 ; k < TOCnumLev.length; k++ ) TOCnumLev[k] = 0;
                g_ooutfile.OutputLnF(TOCnumLev[0] + "." + TOCnumLev[1] + "." + TOCnumLev[2] + "." + TOCnumLev[3] + ". " + NameOfGroup, headertype);  
                break;     
            case 4: 
                TOCnumLev[4]++;
                for (var k = 5 ; k < TOCnumLev.length; k++ ) TOCnumLev[k] = 0;
                g_ooutfile.OutputLnF(TOCnumLev[0] + "." + TOCnumLev[1] + "." + TOCnumLev[2] + "." + TOCnumLev[3] + "." + TOCnumLev[4] + ". " + NameOfGroup, headertype);                     
                break;   
            case 5: 
                TOCnumLev[5]++;
                for (var k = 6 ; k < TOCnumLev.length; k++ ) TOCnumLev[k] = 0;
                g_ooutfile.OutputLnF(TOCnumLev[0] + "." + TOCnumLev[1] + "." + TOCnumLev[2] + "." + TOCnumLev[3] + "." + TOCnumLev[4] + "." + TOCnumLev[5] + ". " + NameOfGroup, headertype);                     
                break; 
            case 6: 
                TOCnumLev[6]++;
                for (var k = 7 ; k < TOCnumLev.length; k++ ) TOCnumLev[k] = 0;
                g_ooutfile.OutputLnF(TOCnumLev[0] + "." + TOCnumLev[1] + "." + TOCnumLev[2] + "." + TOCnumLev[3] + "." + TOCnumLev[4] + "." + TOCnumLev[5] + "." + TOCnumLev[6] + ". " + NameOfGroup, headertype);                     
                break;                 
            default:
                g_ooutfile.OutputLnF(NameOfGroup, headertype); 
         }
    } else g_ooutfile.OutputLnF(NameOfGroup, headertype); 
    if (Spacing) g_ooutfile.OutputLnF("","Regular");
}
//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Начальный диалог
function showOutputOptionsDialog(bcheckuserdialog)
{
    var binput = false;   // Variable to check if input is correct
    var nuserdlg = 0;   // Variable zum Überprüfen ob der Benutzer in den Dialogen Abbrechen gewählt wurde.
    var dialoglogo = Context.getFile("LogoAPB.JPG",Constants.LOCATION_COMMON_FILES);
    
    while (binput == false && ! (nuserdlg == 1)) {
        var userdialog = Dialogs.createNewDialogTemplate(0, 0, 535, 100, "Верхнеуровневое описание БП");
        // Задание и расположение элементов диалога  
        userdialog.Picture(1,2,220,25, "LOGO");  
        userdialog.GroupBox(10, 30, 535, 70, "Настройки отчета");  
        userdialog.CheckBox(20, 45, 600, 15, "Начинать работу со вложенных групп(папкок)", "WorkFromParentGroup");
        userdialog.CheckBox(20, 60, 600, 15, "Выводить графику", "OuputPictures");
        userdialog.CheckBox(20, 75, 600, 15, "Нумеровать заголовки", "TOCNumbering");
        
        userdialog.GroupBox(10, 105, 535, 55, "Определение структуры");
        userdialog.OptionGroup("StructType");
        userdialog.OptionButton(20, 120, 260, 15, "По геометрии");   
        userdialog.OptionButton(20, 135, 260, 15, "По связям");
        
        userdialog.GroupBox(10, 165, 535, 55, "Вид сортировки");
        userdialog.OptionGroup("SortMethod");
        userdialog.OptionButton(20, 180, 260, 15, "По номеру в иерархии");   
        userdialog.OptionButton(20, 195, 260, 15, "По геометрии");
        
        userdialog.OKButton();
        userdialog.CancelButton();
        
        var dlg = Dialogs.createUserDialog(userdialog); 
        dlg.setDlgPicture("LOGO", dialoglogo, 1);
        
        var sSection = "SCRIPT_cd57eb00-25cb-11e8-1e27-0017a4772806";
        ReadSettingsDlgValue(dlg, sSection, "WorkFromParentGroup", __toInteger(0));
        ReadSettingsDlgValue(dlg, sSection, "OuputPictures", __toInteger(1));
        ReadSettingsDlgValue(dlg, sSection, "TOCNumbering", __toInteger(1));
        ReadSettingsDlgValue(dlg, sSection, "StructType", __toInteger(0));
        ReadSettingsDlgValue(dlg, sSection, "SortMethod", __toInteger(1));
        
        nuserdlg = __toLong(Dialogs.show( __currentDialog = dlg));
        
        if (nuserdlg == 0) {
            bcheckuserdialog.value = __toBool(false);
            return;
        } else {
            bcheckuserdialog.value = __toBool(true);
            binput = __toBool(true);
        }
        
        if (nuserdlg != 0) {  
            WriteSettingsDlgValue(dlg, sSection, "WorkFromParentGroup");
            WriteSettingsDlgValue(dlg, sSection, "OuputPictures");
            WriteSettingsDlgValue(dlg, sSection, "TOCNumbering");
            WriteSettingsDlgValue(dlg, sSection, "StructType");
            WriteSettingsDlgValue(dlg, sSection, "SortMethod");
        }
        
        if (dlg.getDlgValue("WorkFromParentGroup")) bcheckuserdialog.workFromParentGroup = __toBool(false);
        else bcheckuserdialog.workFromParentGroup = __toBool(true);
        
        if (dlg.getDlgValue("OuputPictures")) bcheckuserdialog.OuputPictures = __toBool(true);
        else bcheckuserdialog.OuputPictures = __toBool(false);    
        
        if (dlg.getDlgValue("TOCNumbering")) bcheckuserdialog.TOCNumbering = __toBool(true);
        else bcheckuserdialog.TOCNumbering = __toBool(false); 
        
        if (dlg.getDlgValue("StructType")) bcheckuserdialog.GeometryStruct = __toBool(false);
        else bcheckuserdialog.GeometryStruct = __toBool(true);
        
        switch (dlg.getDlgValue("SortMethod")) {
            case 0: 
                bcheckuserdialog.SortMethod = Constants.AT_NAME;
                break;
            case 1:
                bcheckuserdialog.SortMethod = Constants.SORT_GEOMETRIC;
                break;
        }            
    // Show Dialog and waiting for confirmation with  OK
    }
}

//--------------------------------------------------------------------- 
// Функция объединения имени объекта и атрибута описание/определение
function NameDescJoin(ObjOcc)
{
    var NameDescJoinString = ObjOcc.ObjDef().Name(g_nloc);
    NameDescJoinString += " " + ObjOcc.ObjDef().Attribute(Constants.AT_DESC,g_nloc).GetValue(true);
    return NameDescJoinString;
}
//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Функция поиска заданной строки в массиве строк
// массив двумерный, возвращается индекс элемента или -1 если ничего не найдено
function indexOf(oArr,oItem)
{
    for(var i=0;i<oArr.length;i++){
        //if(oArr[i][0].GUID().equals(oItem.GUID())){
        if(oArr[i][0].equals(oItem)) return i;
    }
    return -1;
}
//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Функция вывода графики модели
function PaintPictures(oModel, g_ooutfile){    
    var opicture = oModel.Graphic(false,false,g_nloc); 
    g_ooutfile.BeginParagraph(Constants.FMT_CENTER,0,0,0,0,0);
    g_ooutfile.OutGraphic(opicture,-1,PicW,PicH);  
    g_ooutfile.EndParagraph();
}
//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Функция проверки ориентации вывода на печать модели и задание соответствуещей ориентации листа документа
// для каждой графической модели происходит открытие новой секции 
function CheckOrientation(oModel)
{   
    if (oModel.Flags() & Constants.MODEL_PRINT_LANDSCAPE) LandscapePage(true, g_ooutfile)
    else PortraitPage(true, g_ooutfile);
}
//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Функция простого определения отступов по нумерации в строке (по количеству точек)
// используется для определения отступов при построении структуры по геометрии модели, где другим способом определить отступы нет возможности
// если отступ не определен то вернет 0, если уровней отсупов больше 4 вернет 4, иначе уровень от 0 до 4
function DetectIndentFromNumber(oObjOcc)
{   
    var match = null;  
    var indent = 0;
    match = oObjOcc.ObjDef().Name(g_nloc).match(/\d./g);  
    if (match == null) return 0;
    else {
       indent = match.length-1; 
       if (indent < 0 ) indent = 0;
       if (indent >= 5) indent = 4; 
       return indent; 
    }
}
//--------------------------------------------------------------------- 

//--------------------------------------------------------------------- 
// Функция удаления лишних пробелов в нумерации 
function DeleteNumSpaces(Name)
{   
    Name = String(Name);
    var NameArr = Name.match(/\d./g);
    if (NameArr != null) {
        if (NameArr.length > 0) {
            var posIndex = Name.lastIndexOf(NameArr[NameArr.length-1]);
            if (posIndex == -1) return Name
            else {    
                var BPNum = Name.substring(0,posIndex).replace(" ","");
                var BPName = Name.substring(posIndex, Name.length);
                var Result = BPNum + BPName;
                return Result
            }
        } else return Name;
    } else return Name;
}
//--------------------------------------------------------------------- 

main();
